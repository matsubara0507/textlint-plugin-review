{"version":3,"sources":["../src/block-parsers.js"],"names":["parseBlockWithContent","parseBlockArg","BlockParsers","table","withCaption","parseTable","footnote","parseFootnote","quote","parseQuote","list","parseCodeBlock","listnum","emlist","emlistnum","source","cmd","image","parseImage","indepimage","numberlessimage","graph","imgtable","lead","parseLead","read","note","parseShortColumn","memo","tip","info","warning","important","caution","notice","captionIndex","blockParser","block","node","blockArg","args","caption","Syntax","Caption","chunk","lines","children","unshift","Table","slice","length","forEach","Array","prototype","push","apply","parseTableContent","line","isComment","text","match","nodes","cellRegex","exec","startColumn","index","cellContent","startsWith","substr","context","cellNode","TableCell","Footnote","footnoteParagraph","Paragraph","Quote","CodeBlock","value","filter","map","raw","join","Image","Lead","ShortColumn","type","flushParagraph","paragraph","argText","blockArgContext","argNode"],"mappings":"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","file":"block-parsers.js","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport { Syntax } from './mapping';\nimport { parseText, parseLine } from './inline-parsers';\nimport {\n  createNodeFromChunk, createNodeFromLinesInChunk, createCommentNodeFromLine, createInlineNode,\n  contextFromLine, contextNeedsUnescapeBrackets\n} from './parser-utils';\n\nexport const BlockParsers = {\n  table: withCaption(1, parseTable),\n  footnote: parseFootnote,\n  quote: parseQuote,\n\n  list: withCaption(1, parseCodeBlock),\n  listnum: withCaption(1, parseCodeBlock),\n  emlist: withCaption(0, parseCodeBlock),\n  emlistnum: withCaption(0, parseCodeBlock),\n  source: parseCodeBlock,\n  cmd: parseCodeBlock,\n\n  image: withCaption(1, parseImage),\n  indepimage: withCaption(1, parseImage),\n  numberlessimage: withCaption(1, parseImage),\n  graph: withCaption(2, parseImage),\n  imgtable: withCaption(1, parseImage),\n\n  lead: parseLead,\n  read: parseLead,\n\n  note: withCaption(0, parseShortColumn),\n  memo: withCaption(0, parseShortColumn),\n  tip: withCaption(0, parseShortColumn),\n  info: withCaption(0, parseShortColumn),\n  warning: withCaption(0, parseShortColumn),\n  important: withCaption(0, parseShortColumn),\n  caution: withCaption(0, parseShortColumn),\n  notice: withCaption(0, parseShortColumn),\n};\n\n/**\n * return new parser to parse block with caption.\n * @param {number} captionIndex - index of caption in block args\n * @param {function} blockParser - Parser function of a block\n * @return {function} parser function\n */\nfunction withCaption(captionIndex, blockParser) {\n  return function (block) {\n    const node = blockParser(block);\n\n    if (captionIndex !== null) {\n      const blockArg = block.args[captionIndex];\n      if (blockArg) {\n        const caption = parseBlockArg(Syntax.Caption, blockArg, block.chunk.lines[0]);\n        if (caption) {\n          node.children = node.children || [];\n          node.children.unshift(caption);\n        }\n      }\n    }\n\n    return node;\n  };\n}\n\n/**\n * parse table block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} Table node\n */\nfunction parseTable(block) {\n  const node = createNodeFromChunk(block.chunk, Syntax.Table);\n  node.children = [];\n\n  block.chunk.lines.slice(1, block.chunk.lines.length - 1).forEach(line => {\n    Array.prototype.push.apply(node.children, parseTableContent(line));\n  });\n\n  return node;\n}\n\n/**\n * parse line in a table.\n * @param {Line} line - Line to parse\n * @return {[TxtNode]} ListItem nodes in the line\n */\nfunction parseTableContent(line) {\n  if (line.isComment) {\n    return [createCommentNodeFromLine(line)];\n  }\n\n  if (line.text.match(/^-+$/)) {\n    return [];  // Ignore horizontal line\n  }\n\n  const nodes = [];\n  const cellRegex = /[^\\t]+/g;\n  var match;\n  while (match = cellRegex.exec(line.text)) {\n    let startColumn = match.index;\n    let cellContent = match[0];\n    if (cellContent.startsWith('.')) {\n      cellContent = cellContent.substr(1);\n      startColumn += 1;\n    }\n\n    if (cellContent === '') {\n      continue;\n    }\n\n    const context = contextFromLine(line, startColumn);\n    const cellNode = createInlineNode(Syntax.TableCell, cellContent, context);\n    cellNode.children = parseText(cellContent, context);\n    nodes.push(cellNode);\n  }\n\n  return nodes;\n}\n\n/**\n * parse footnote block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} Footnote node\n */\nfunction parseFootnote(block) {\n  const node = createNodeFromChunk(block.chunk, Syntax.Footnote);\n  const footnoteParagraph = parseBlockArg(Syntax.Paragraph, block.args[1], block.chunk.lines[0]);\n  if (footnoteParagraph) {\n    node.children = [footnoteParagraph];\n  }\n\n  return node;\n}\n\n/**\n * parse quote block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} BlockQuote node\n */\nfunction parseQuote(block) {\n  return parseBlockWithContent(block, Syntax.Quote);\n}\n\n/**\n * parse code block, e.g //list, //emlist, //source etc.\n * @param {Block} block - Block to parse\n * @return {TxtNode} CodeBlock node\n */\nfunction parseCodeBlock(block) {\n  const node = createNodeFromChunk(block.chunk, Syntax.CodeBlock);\n  node.value = block.chunk.lines\n    .slice(1, block.chunk.lines.length - 1)\n    .filter(line => !line.isComment)\n    .map(line => line.raw)\n    .join('');\n  return node;\n}\n\n/**\n * parse image block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} Image node\n */\nfunction parseImage(block) {\n  return createNodeFromChunk(block.chunk, Syntax.Image);\n}\n\n/**\n * parse lead block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} Block node\n */\nfunction parseLead(block) {\n  return parseBlockWithContent(block, Syntax.Lead);\n}\n\n/**\n * parse various short column block.\n * @param {Block} block - Block to parse\n * @return {TxtNode} Block node\n */\nfunction parseShortColumn(block) {\n  return parseBlockWithContent(block, Syntax.ShortColumn);\n}\n\n/**\n * parse a block with content. which is parsed as paragraphs.\n * @param {Block} block - line to parse\n * @param {string} type - Type of node\n * @return {[TxtNode]} TxtNode\n */\nexport function parseBlockWithContent(block, type) {\n  const chunk = block.chunk;\n  const node = createNodeFromChunk(chunk, type);\n  node.children = [];\n\n  let lines = [];\n  const flushParagraph = function () {\n    if (lines.length > 0) {\n      const paragraph = createNodeFromLinesInChunk(Syntax.Paragraph, lines, chunk);\n      paragraph.children = [];\n      lines.forEach(line => {\n        Array.prototype.push.apply(paragraph.children, parseLine(line));\n      });\n      node.children.push(paragraph);\n    }\n\n    lines = [];\n  };\n\n  chunk.lines.slice(1, chunk.lines.length - 1).forEach(line => {\n    if (line.text === '') {\n      flushParagraph();\n    } else {\n      lines.push(line);\n    }\n  });\n\n  flushParagraph();\n\n  return node;\n}\n\n/**\n * parse single argument of a block as a TxtNode\n * @param {string} type - Type of node\n * @param {Arg} blockArg - Arg of a block to parse\n * @param {Line} line - line where Arg exists\n * @return {TxtNode}\n */\nexport function parseBlockArg(type, blockArg, line) {\n  const argText = blockArg.value;\n  if (!argText) {\n    return null;\n  }\n\n  const startColumn = blockArg.startColumn;\n  const blockArgContext = contextNeedsUnescapeBrackets(contextFromLine(line, startColumn));\n  const argNode = createInlineNode(type, argText, blockArgContext);\n  argNode.children = parseText(argText, blockArgContext);\n  return argNode;\n}\n\n"]}