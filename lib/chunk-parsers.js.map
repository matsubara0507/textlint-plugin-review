{"version":3,"sources":["../src/chunk-parsers.js"],"names":["parseParagraph","parseHeading","parseList","parseBlock","parseComment","ChunkParsers","Paragraph","Heading","UnorderedList","chunk","OrderedList","DefinitionList","Block","Comment","node","children","lines","forEach","Array","prototype","push","apply","line","length","match","text","depth","label","trim","labelOffset","indexOf","strNode","heading","Syntax","prefixRegex","isComment","itemNode","ListItem","itemText","replace","startColumn","block","name","args","parser","BlockParsers"],"mappings":"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","file":"chunk-parsers.js","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\nimport { BlockParsers } from './block-parsers';\nimport { parseText, parseLine } from './inline-parsers';\nimport {\n  parseBlockArgs, createNodeFromChunk, createNodeFromLine, createCommentNodeFromLine,\n  createStrNode, contextFromLine\n} from './parser-utils';\n\nexport const ChunkParsers = {\n  Paragraph: parseParagraph,\n  Heading: parseHeading,\n  UnorderedList: chunk => parseList(/^\\s+\\*+\\s+/, chunk),\n  OrderedList: chunk => parseList(/^\\s+\\d+\\.\\s+/, chunk),\n  DefinitionList: chunk => parseList(/^(\\s+:\\s+|\\s+)/, chunk),\n  Block: parseBlock,\n  Comment: parseComment,\n};\n\n/**\n * parse paragraph chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Paragraph node\n */\nexport function parseParagraph(chunk) {\n  const node = createNodeFromChunk(chunk);\n  node.children = [];\n  chunk.lines.forEach(line => {\n    Array.prototype.push.apply(node.children, parseLine(line));\n  });\n  return node;\n}\n\n/**\n * parse heading chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Heading node\n */\nexport function parseHeading(chunk) {\n  assert(chunk.lines.length === 1);\n  const line = chunk.lines[0];\n  const match = line.text.match(/(=+)\\S*\\s*(.*)/);  // \\S* skip [column] and {ch01}\n  const depth = match[1].length;\n  const label = match[2].trim();\n  const labelOffset = line.text.indexOf(label);\n  assert(labelOffset >= 0);\n  const strNode = createStrNode(label, contextFromLine(line, labelOffset));\n  const heading = createNodeFromLine(Syntax.Heading, line);\n  heading.depth = depth;\n  heading.label = label;\n  heading.children = [strNode];\n\n  return heading;\n}\n\n/**\n * parse list chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Block node\n */\nexport function parseList(prefixRegex, chunk) {\n  const node = createNodeFromChunk(chunk);\n  node.children = [];\n  chunk.lines.forEach(line => {\n    if (line.isComment) {\n      node.children.push(createCommentNodeFromLine(line));\n      return;\n    }\n\n    const itemNode = createNodeFromLine(Syntax.ListItem, line);\n    itemNode.children = [];\n    const itemText = line.text.replace(prefixRegex, '');\n    const startColumn = line.text.length - itemText.length;\n    Array.prototype.push.apply(itemNode.children,\n                               parseText(itemText, contextFromLine(line, startColumn)));\n\n    node.children.push(itemNode);\n  });\n  return node;\n}\n\n/**\n * parse block chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Block node\n */\nexport function parseBlock(chunk) {\n  const line = chunk.lines[0];\n  const match = line.text.match(/^\\/\\/(\\w+)(.*)\\{?$/);\n  const block = {\n    name: match[1],\n    args: parseBlockArgs(match[2], 2 + match[1].length),\n    chunk: chunk,\n  };\n  const parser = BlockParsers[block.name];\n\n  if (!parser) {\n    return null;\n  }\n\n  return parser(block);\n}\n\n/**\n * parse comment chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode}  node\n */\nexport function parseComment(chunk) {\n  assert(chunk.lines.length === 1);\n  const node = createCommentNodeFromLine(chunk.lines[0]);\n\n  return node;\n}\n"]}