{"version":3,"sources":["../src/chunker.js"],"names":["parseAsChunks","ChunkTypes","Paragraph","Heading","UnorderedList","OrderedList","DefinitionList","Block","Comment","text","lines","match","startIndex","currentChunk","chunks","reduce","result","currentLine","index","line","raw","replace","lineNumber","parseLine","length","forEach","firstLineIndex","chunk","lastLineIndex","slice","join","startsWith","isComment","push","createChunk","type","flushChunk","endsWith","firstLine"],"mappings":"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","file":"chunker.js","sourcesContent":["// LICENSE : MIT\n'use strict';\n\nexport const ChunkTypes = {\n  Paragraph: 'Paragraph',\n  Heading: 'Heading',\n  UnorderedList: 'UnorderedList',\n  OrderedList: 'OrderedList',\n  DefinitionList: 'DefinitionList',\n  Block: 'Block',\n\n  // NOTE: Comment chunk means an independent comment line. Other chunks may include comment lines.\n  Comment: 'Comment',\n};\n\n/**\n * parse text and return array of chunks.\n * @param {string} text\n * @return {[Chunk]}\n */\nexport function parseAsChunks(text) {\n  const lines = text.match(/(?:.*\\r?\\n|.+$)/g); // split lines preserving line endings\n  //console.log(lines);\n  var startIndex = 0;\n  var currentChunk = null;\n\n  const chunks = lines.reduce(function (result, currentLine, index) {\n    const line = {\n      raw: currentLine, // with line endings\n      text: currentLine.replace(/\\r?\\n$/, ''), // without line endings\n      lineNumber: index + 1,\n      startIndex: startIndex,\n    };\n    parseLine(result, line);\n    startIndex += currentLine.length;\n    return result;\n  }, []);\n\n  chunks.forEach(chunk => {\n    const firstLineIndex = chunk.lines[0].lineNumber - 1;\n    const lastLineIndex = chunk.lines[chunk.lines.length - 1].lineNumber - 1;\n    chunk.raw = lines.slice(firstLineIndex, lastLineIndex + 1).join('');\n  });\n\n  return chunks;\n\n  function parseLine(result, line) {\n    // comment\n    // NOTE: comment does not break current chunk, i.e. a block can contain comments in its body.\n    if (line.text.startsWith('#@')) {\n      line.isComment = true;\n      if (currentChunk) {\n        currentChunk.lines.push(line);\n      } else {\n        // A comment line corresponds to a Comment chunk.\n        result.push(createChunk(ChunkTypes.Comment, line));\n      }\n\n      return;\n    }\n\n    // block content\n    if (currentChunk && currentChunk.type === ChunkTypes.Block) {\n      currentChunk.lines.push(line);\n      if (line.text.startsWith('//}')) {\n        flushChunk(); // end of block\n      }\n\n      return;\n    }\n\n    // block open\n    if (line.text.match(/^\\/\\/\\w+/)) {\n      flushChunk();\n      const chunk = createChunk(ChunkTypes.Block, line);\n      result.push(chunk);\n      if (line.text.endsWith('{')) {\n        // block with open and end tags, e.g. //list, //emlist, etc.\n        currentChunk = chunk;\n      }\n\n      return;\n    }\n\n    // heading\n    if (line.text.startsWith('=')) {\n      flushChunk();\n      result.push(createChunk(ChunkTypes.Heading, line));\n      return;\n    }\n\n    // unordered list\n    if (line.text.match(/^\\s+\\*+\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.UnorderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.UnorderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // ordered list\n    if (line.text.match(/^\\s+\\d+\\.\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.OrderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.OrderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // definition list\n    if (line.text.match(/^\\s+:\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.DefinitionList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // continuation line of definition list\n    if (line.text.match(/^\\s+/) &&\n        currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n      currentChunk.lines.push(line);\n      return;\n    }\n\n    // empty line\n    if (line.text === '') {\n      flushChunk();\n      return;\n    }\n\n    // normal string\n    if (currentChunk && currentChunk.type === ChunkTypes.Paragraph) {\n      currentChunk.lines.push(line);\n    } else {\n      flushChunk();\n      currentChunk = createChunk(ChunkTypes.Paragraph, line);\n      result.push(currentChunk);\n    }\n  }\n\n  function flushChunk() {\n    currentChunk = null;\n  }\n\n  function createChunk(type, firstLine) {\n    return {\n      type: type,\n      lines: [firstLine],\n    };\n  }\n}\n"]}