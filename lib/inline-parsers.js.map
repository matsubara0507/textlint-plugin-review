{"version":3,"sources":["../src/inline-parsers.js"],"names":["parseLine","parseText","line","isComment","text","InlineParsers","bou","inlineTextTagParser","Syntax","Bouten","ami","Amikake","u","Underline","b","Bold","i","Italic","strong","Strong","em","Emphasis","tt","Teletype","tti","TeletypeItalic","ttb","TeletypeBold","tcy","TateChuYoko","kw","parseKeywordTag","ruby","parseRubyTag","href","parseHrefTag","chap","inlineNonTextTagParser","Reference","title","chapref","list","img","table","hd","column","fn","code","withValue","Code","comment","Comment","uchar","UnicodeChar","br","Break","icon","Icon","m","Math","raw","Raw","inlineParser","tag","context","node","value","content","type","parseInlineNonTextTag","parseInlineTextTag","fullText","strContext","index","strNode","children","Keyword","pieces","split","word","length","alt","Href","url","label","labelOffset","indexOf","Ruby","rubyBase","rubyText","match","nodes","precedingText","push","parser","name","followingText"],"mappings":"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","file":"inline-parsers.js","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\nimport {\n  parseBlockArg, findInlineTag, createNodeFromChunk, createCommentNodeFromLine, createStrNode,\n  createInlineNode, contextFromLine, offsetContext, contextNeedsUnescapeBraces, unescapeValue\n} from './parser-utils';\n\n/**\n * parse a line.\n * @param {Line} line - line to parse\n * @return {[TxtNode]} TxtNodes\n */\nexport function parseLine(line) {\n  if (line.isComment) {\n    return [createCommentNodeFromLine(line)];\n  }\n\n  return parseText(line.text, contextFromLine(line));\n}\n\nconst InlineParsers = {\n  // text tags\n  bou:     inlineTextTagParser(Syntax.Bouten),\n  ami:     inlineTextTagParser(Syntax.Amikake),\n  u:       inlineTextTagParser(Syntax.Underline),\n  b:       inlineTextTagParser(Syntax.Bold),\n  i:       inlineTextTagParser(Syntax.Italic),\n  strong:  inlineTextTagParser(Syntax.Strong),\n  em:      inlineTextTagParser(Syntax.Emphasis),\n  tt:      inlineTextTagParser(Syntax.Teletype),\n  tti:     inlineTextTagParser(Syntax.TeletypeItalic),\n  ttb:     inlineTextTagParser(Syntax.TeletypeBold),\n  tcy:     inlineTextTagParser(Syntax.TateChuYoko),\n\n  // partially text tags\n  kw:      parseKeywordTag,\n  ruby:    parseRubyTag,\n  href:    parseHrefTag,\n\n  // non-text tags\n  chap:    inlineNonTextTagParser(Syntax.Reference),\n  title:   inlineNonTextTagParser(Syntax.Reference),\n  chapref: inlineNonTextTagParser(Syntax.Reference),\n  list:    inlineNonTextTagParser(Syntax.Reference),\n  img:     inlineNonTextTagParser(Syntax.Reference),\n  table:   inlineNonTextTagParser(Syntax.Reference),\n  hd:      inlineNonTextTagParser(Syntax.Reference),\n  column:  inlineNonTextTagParser(Syntax.Reference),\n  fn:      inlineNonTextTagParser(Syntax.Reference),\n\n  code:    withValue(inlineNonTextTagParser(Syntax.Code)),\n  comment: withValue(inlineNonTextTagParser(Syntax.Comment)),\n  uchar:   inlineNonTextTagParser(Syntax.UnicodeChar),\n  br:      inlineNonTextTagParser(Syntax.Break),\n  icon:    inlineNonTextTagParser(Syntax.Icon),\n  m:       inlineNonTextTagParser(Syntax.Math),\n  raw:     inlineNonTextTagParser(Syntax.Raw),\n};\n\n/**\n * get new inline tag parser to get value attribute.\n * @param {function} inlineParser - Parser function of a inline tag\n * @return {function} parser function\n */\nfunction withValue(inlineParser) {\n  return (tag, context) => {\n    const node = inlineParser(tag, context);\n    node.value = unescapeValue(tag.content.raw, context);\n    return node;\n  };\n}\n\n/**\n * get non-text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineNonTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineNonTextTag(type, tag, context);\n}\n\n/**\n * get text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineTextTag(type, tag, context);\n}\n\n/**\n * parse non-text tag, which has no child.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineNonTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  return node;\n}\n\n/**\n * parse text tag, which has child Str node.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  const strContext = offsetContext(context, tag.content.index);\n  const strNode = createStrNode(tag.content.raw, strContext);\n  node.children = [strNode];\n  return node;\n}\n\n/**\n * parse @<kw>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseKeywordTag(tag, context) {\n  const node = createInlineNode(Syntax.Keyword, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const word = pieces[0];\n  if (pieces.length === 2) {\n    node.alt = pieces[1];\n  }\n\n  const strNode = createStrNode(word, offsetContext(context, tag.content.index));\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<href>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseHrefTag(tag, context) {\n  const node = createInlineNode(Syntax.Href, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const url = pieces[0];\n  let label;\n  let labelOffset;\n  if (pieces.length === 2) {\n    label = pieces[1];\n    labelOffset = tag.content.index + tag.content.raw.indexOf(label, url.length);\n    assert(labelOffset >= tag.content.index);\n  } else {\n    label = url;\n    labelOffset = tag.content.index;\n  }\n\n  const strContext = offsetContext(context, labelOffset);\n  const strNode = createStrNode(label, strContext);\n\n  node.url = url;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<ruby>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseRubyTag(tag, context) {\n  const node = createInlineNode(Syntax.Ruby, tag.fullText, context);\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  assert(pieces.length === 2);\n  const rubyBase = pieces[0];\n  const rubyText = pieces[1];\n\n  const strNode = createStrNode(rubyBase, offsetContext(context, tag.content.index));\n\n  node.rubyText = rubyText;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse inline tags and StrNodes from line.\n * @param {string} text - Text of the line\n * @param {Context} context - context of the node\n * @return {[TxtNode]} TxtNodes in the line\n */\nexport function parseText(text, context) {\n  assert(!text.match(/[\\r\\n]/));\n\n  const nodes = [];\n  let tag;\n  while (tag = findInlineTag(text)) {\n    if (tag.precedingText !== '') {\n      const node = createStrNode(tag.precedingText, context);\n      nodes.push(node);\n      context = offsetContext(context, node.raw.length);\n    }\n\n    const parser = InlineParsers[tag.name];\n    if (parser) {\n      const node = parser(tag, contextNeedsUnescapeBraces(context));\n      nodes.push(node);\n    }\n\n    context = offsetContext(context, tag.fullText.length);\n    text = tag.followingText;\n  }\n\n  if (text.length) {\n    const node = createStrNode(text, context);\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\n"]}