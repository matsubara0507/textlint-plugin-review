{"version":3,"sources":["../src/parser-utils.js"],"names":["parseBlockArgs","findInlineTag","createNodeFromChunk","createNodeFromLinesInChunk","createNodeFromLine","createCommentNodeFromLine","createStrNode","unescapeValue","createInlineNode","contextFromLine","offsetContext","contextNeedsUnescapeBraces","contextNeedsUnescapeBrackets","argsText","offset","argRegex","args","openIndex","closeIndex","findCloseBracket","push","value","slice","startColumn","text","match","contentStartIndex","index","length","contentCloseIndex","rawContent","substr","tag","name","content","raw","fullText","precedingText","followingText","character","fromIndex","indexOf","chunk","type","Syntax","lines","firstLine","lastLine","chunkStartIndex","startIndex","endIndex","range","loc","start","line","lineNumber","column","end","isComment","node","Comment","context","Str","unescapeBraces","replace","unescapeBrackets","originalContext","newContext","Object","assign"],"mappings":"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","file":"parser-utils.js","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\n\n/**\n * parse arguments of a block like \"[foo][This is foo]\".\n * @param {string} argsText - String to parse\n * @param {number} offset - Offset index where the args starts with in the line\n * @return {[Arg]} Array of Args\n */\nexport function parseBlockArgs(argsText, offset) {\n  const argRegex = /\\[(.*?)\\]/g;\n  const args = [];\n\n  let openIndex = 0;\n  while (argsText[openIndex] === '[') {\n    let closeIndex = findCloseBracket(argsText, ']', openIndex);\n\n    args.push({\n      value: argsText.slice(openIndex + 1, closeIndex),\n      startColumn: offset + openIndex + 1,\n    });\n\n    openIndex = closeIndex + 1;\n  }\n\n  return args;\n}\n\n/**\n * find inline tag from text\n * @param {string} text - Text to parse\n * @return {Tag} the first Tag object if inline tag found, otherwise null\n */\nexport function findInlineTag(text) {\n  const match = text.match(/@<(\\w+)>\\{/);\n  if (!match) {\n    return null; // inline tag not found\n  }\n\n  // We need to ignore escaped closing brace \\}.\n  // As look-behind expression is relatively new, use indexOf()\n  let contentStartIndex = match.index + match[0].length;\n  let closeIndex = findCloseBracket(text, '}', contentStartIndex);\n  if (closeIndex < 0) {\n    return null; // not found\n  }\n\n  const contentCloseIndex = closeIndex - 1;\n  const rawContent = text.substr(contentStartIndex, contentCloseIndex - contentStartIndex + 1);\n  const tag = {\n    name: match[1],\n    content: {\n      raw: rawContent,\n      index: contentStartIndex - match.index,\n    },\n    fullText: text.substr(match.index, closeIndex - match.index + 1),\n    precedingText: text.substr(0, match.index),\n    followingText: text.substr(closeIndex + 1),\n  };\n\n  return tag;\n}\n\nfunction findCloseBracket(text, character, fromIndex=0) {\n  let closeIndex;\n  while (true) {\n    closeIndex = text.indexOf(character, fromIndex);\n    if (closeIndex < 0) {\n      break; // closing } not found. this is normal string not a inline tag\n    }\n\n    if (text[closeIndex - 1] !== '\\\\') {\n      break; // found closing } which is not escaped\n    }\n\n    fromIndex = closeIndex + 1;\n  }\n\n  return closeIndex;\n}\n\n/**\n * create TxtNode from chunk.\n * @param {Chunk} chunk - A chunk\n * @param {string} [type=chunk.type] - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromChunk(chunk, type) {\n  type = type || Syntax[chunk.type];\n  return createNodeFromLinesInChunk(type, chunk.lines, chunk);\n}\n\n/**\n * create TxtNode from lines in a chunk.\n * @param {string} type - Type of node\n * @param {[Line]} lines - lines in a chunk\n * @param {Chunk} chunk - A chunk\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLinesInChunk(type, lines, chunk) {\n  const firstLine = lines[0];\n  const lastLine = lines[lines.length - 1];\n  const chunkStartIndex = chunk.lines[0].startIndex;\n  const startIndex = firstLine.startIndex;\n  const endIndex = lastLine.startIndex + lastLine.text.length;\n  const text = chunk.raw.slice(startIndex - chunkStartIndex, endIndex - chunkStartIndex);\n\n  return {\n    type: type,\n    raw: text,\n    range: [startIndex, endIndex],\n    loc: {\n      start: {\n        line: firstLine.lineNumber,\n        column: 0,\n      },\n      end: {\n        line: lastLine.lineNumber,\n        column: lastLine.text.length,\n      },\n    },\n  };\n}\n\n/**\n * create TxtNode from single line.\n * @param {Line} line - A line\n * @param {string} type - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLine(type, line) {\n  assert(!line.isComment);\n  return createInlineNode(type, line.text, contextFromLine(line));\n}\n\n/**\n * create comment TxtNode from single line.\n * @param {Line} line - A line\n * @return {TxtNode} Created TxtNode\n */\nexport function createCommentNodeFromLine(line) {\n  assert(line.isComment);\n  const node = createInlineNode(Syntax.Comment, line.text, contextFromLine(line));\n  let match;\n  if (match = line.text.match(/^#@#\\s*(.*)/)) {\n    node.value = match[1];\n  } else if (match = line.text.match(/^#@warn\\((.*)\\)/)) {\n    node.value = match[1];\n  } else {\n    node.value = line.text;\n  }\n\n  return node;\n}\n\n/**\n * create Str TxtNode.\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createStrNode(raw, context) {\n  const node = createInlineNode(Syntax.Str, raw, context);\n  node.value = unescapeValue(raw, context);\n  return node;\n}\n\n/**\n * unescape value considering context\n * @param {string} value - Value to unescape\n * @param {Context} context - context of unescape\n * @return {string} Unescaped value\n */\nexport function unescapeValue(value, context) {\n  if (context.unescapeBraces) {\n    value = value.replace(/\\\\\\}/g, '}');\n  }\n\n  if (context.unescapeBrackets) {\n    value = value.replace(/\\\\\\]/g, ']');\n  }\n\n  return value;\n}\n\n/**\n * create inline TxtNode.\n * @param {string} type - Type of node\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createInlineNode(type, raw, context) {\n  assert(!raw.match(/[\\r\\n]/));\n\n  return {\n    type: type,\n    raw: raw,\n    range: [context.startIndex, context.startIndex + raw.length],\n    loc: {\n      start: {\n        line: context.lineNumber,\n        column: context.startColumn,\n      },\n      end: {\n        line: context.lineNumber,\n        column: context.startColumn + raw.length,\n      },\n    },\n  };\n}\n\n/**\n * create context from Line.\n * @param {Line} line - Line object\n * @param {number} [offset=0] - Column offset\n * @return {Context} Created Context object\n */\nexport function contextFromLine(line, offset=0) {\n  return {\n    startIndex: line.startIndex + offset,\n    lineNumber: line.lineNumber,\n    startColumn: offset,\n  };\n}\n\n/**\n * create new context with offset from original context.\n * @param {Context} originalContext - Original Context object\n * @param {number} offset - Column offset\n * @return {Context} New Context object\n */\nexport function offsetContext(originalContext, offset) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.startIndex += offset;\n  newContext.startColumn += offset;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBraces = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBraces(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBraces = true;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBrackets = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBrackets(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBrackets = true;\n  return newContext;\n}\n"]}