{"version":3,"sources":["../src/review-to-ast.js"],"names":["parse","text","lines","match","chunks","nodes","forEach","parser","ChunkParsers","chunk","type","node","push","ast","Syntax","Document","raw","range","length","loc","start","line","column","end","children","validateAST","prevNode","enter","slice","firstLine","startsWith","substr","lastLine","endsWith","ex","console","log"],"mappings":"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","file":"review-to-ast.js","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { traverse } from '@textlint/ast-traverse';\nimport { test as testTextlintAST } from '@textlint/ast-tester';\nimport { Syntax } from './mapping';\nimport { parseAsChunks } from './chunker';\nimport { ChunkParsers } from './chunk-parsers';\n\n/**\n * parse text and return ast mapped location info.\n * @param {string} text\n * @return {TxtNode}\n */\nexport function parse(text) {\n  const lines = text.match(/(?:.*\\r?\\n|.+$)/g); // split lines preserving line endings\n  const chunks = parseAsChunks(text);\n  const nodes = [];\n  chunks.forEach(chunk => {\n    const parser = ChunkParsers[chunk.type];\n    const node = parser(chunk);\n    if (node !== null) {\n      nodes.push(node);\n    }\n  });\n\n  const ast = {\n    type: Syntax.Document,\n    raw: text,\n    range: [0, text.length],\n    loc: {\n      start: {\n        line: 1,\n        column: 0,\n      },\n      end: {\n        line: lines.length,\n        column: lines[lines.length - 1].length,\n      },\n    },\n    children: nodes,\n  };\n\n  validateAST(ast, text, lines);\n\n  return ast;\n}\n\nfunction validateAST(ast, text, lines) {\n  testTextlintAST(ast);\n\n  let prevNode = ast;\n  traverse(ast, {\n    enter(node) {\n      try {\n        assert(node.raw === text.slice(node.range[0], node.range[1]));\n\n        if (node.loc.start.line === node.loc.end.line) {\n          // single line\n          const line = lines[node.loc.start.line - 1];\n          assert(node.raw === line.slice(node.loc.start.column, node.loc.end.column));\n        } else {\n          // multi line\n          const firstLine = lines[node.loc.start.line - 1];\n          assert(node.raw.startsWith(firstLine.substr(node.loc.start.column)));\n          const lastLine = lines[node.loc.end.line - 1];\n          assert(node.raw.endsWith(lastLine.substr(0, node.loc.end.column)));\n        }\n      } catch (ex) {\n        console.log('type: %s, line: %s, column: %s',\n                    prevNode.type, prevNode.loc.start.line, prevNode.loc.start.column);\n        console.log('type: %s, line: %s, column: %s',\n                    node.type, node.loc.start.line, node.loc.start.column);\n        throw ex;\n      }\n\n      prevNode = node;\n    },\n  });\n\n}\n"]}